/* 
 * Tux Racer 
 * Copyright (C) 1999-2000 Jasmin F. Patry
 * 
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */


#include "tuxracer.h"
#include "course_load.h"
#include "course_render.h"
#include "hier.h"
#include "hier_util.h"
#include "tux.h"
#include "part_sys.h"
#include "phys_sim.h"
#include "nmrcl.h"

/* Set this to 1 if Tux sometimes passes through trees... */
#define USE_MIN_TIME_STEP_FOR_TREE_COLLISIONS 0

/*
 * Constants
 */

/* Tux's mass (kg) */
#define TUX_MASS 20

/* Minimum speed (m/s) */
#define MIN_TUX_SPEED 1.4

/* Initial Tux speed (m/s) */
#define INIT_TUX_SPEED 3.0

/* Maximum angle by which frictional force is rotated when turning*/
#define MAX_TURN_ANGLE 60

/* Maximum increase in friction when turning */
#define MAX_TURN_PENALTY 0.3

/* Force applied by Tux when braking */
#define BRAKE_FORCE 400

/* Tux's orientation is updated using a first-order filter; these are the 
   time constants of the filter when tux is on ground and airborne (s) */
#define TUX_ORIENTATION_TIME_CONSTANT 0.14
#define TUX_ORIENTATION_AIRBORNE_TIME_CONSTANT 0.8

/* Max particles generated by turning (particles/s) */
#define MAX_TURN_PARTICLES 3000

/* Particles generated by braking (particles/s) */
#define BRAKE_PARTICLES 6000

/* Number of particles is multiplied by ( speed / PARTICLES_SPEED_FACTOR ) */
#define PARTICLES_SPEED_FACTOR 40

/* The compressiblity of the first section of the spring modelling Tux's
   tush (m) */
#define TUX_GLUTE_STAGE_1_COMPRESSIBILITY 0.12

/* The spring coefficient of first section of aforementioned tush (N/m) */
#define TUX_GLUTE_STAGE_1_SPRING_COEFF 3000

/* The damping coefficient of first section of aforementioned tush (N*s/m) */
#define TUX_GLUTE_STAGE_1_DAMPING_COEFF 500

/* The spring coefficient of second section of aforementioned tush (N/m) */
#define TUX_GLUTE_STAGE_2_SPRING_COEFF 10000

/* The damping coefficient of second section of aforementioned tush (N*s/m) */
#define TUX_GLUTE_STAGE_2_DAMPING_COEFF 1000

/* The maximum force exertedd by both sections of spring (N) */
#define TUX_GLUTE_MAX_SPRING_FORCE 3000

/* Density of air @ -3 C (kg/m^3) */
#define AIR_DENSITY 1.308

/* Diameter of sphere used to model Tux for air resistance calcs (m) */
#define TUX_DIAMETER 0.4

/* Viscosity of air @ -3 C (N*s/m^2) */
#define AIR_VISCOSITY 17.00e-6

/* Drag coefficient vs. Reynolds number table (from Janna, _Introduction to
   Fluid Mechanics_, 3rd Edition, PWS-Kent, p 308) 
   Values are for Re in the range of 10^-1 to 10^6, spaced logarithmically
   (all values are log base 10) */
static const double air_log_re[] = { -1,
				     0,
				     1,
				     2,
				     3,
				     4,
				     5,
				     6 };
static const double air_log_drag_coeff[] = { 2.25,
					     1.35,
					     0.6,
					     0.0,
					     -0.35,
					     -0.45,
					     -0.33,
					     -0.9 };

/* Minimum time step for ODE solver (s) */
#define MIN_TIME_STEP 0.001

/* Maximum time step for ODE solver (s) */
#define MAX_TIME_STEP 0.05

/* Maximum distance of step for ODE solver (m) */
#define MAX_STEP_DISTANCE 0.10

/* Tolerance on error in Tux's position (m) */
#define MAX_POSITION_ERROR 1.e-5

/* Tolerance on error in Tux's velocity (m/s) */
#define MAX_VELOCITY_ERROR 1.e-4

/* To smooth out the terrain, the terrain normals are interpolated
   near the edges of the triangles.  This parameter controls how much
   smoothing is done, as well as the size of the triangle boundary
   over which smoothing occurs.  A value of 0 will result in no
   smoothing, while a value of 0.5 will smooth the normals over the
   entire surface of the triangle (though the smoothing will increase
   as the value approaches infinity).  (dimensionless) */
#define NORMAL_INTERPOLATION_LIMIT 0.05

/* The distance to move Tux up by so that he doesn't sit too low on the 
   ground (m) */
#define TUX_Y_CORRECTION 0.19

/* The square of the distance that Tux must move before we recompute a 
   collision (m^2) */
#define COLLISION_TOLERANCE 0.0025

/*
 * Static variables
 */

/* Friction coefficients (dimensionless) */
static scalar_t  fricCoeff[3] = { 0.35, /* ice */
                                  0.7,  /* rock */
                                  0.45  /* snow */
                                };

/* Current time step in ODE solver */
static double ode_time_step = -1;


/*
 * Function definitions
 */

void increment_turn_fact( player_data_t *plyr, scalar_t amt )
{
    plyr->control.turn_fact += amt;
    plyr->control.turn_fact = min( 1.0, max( plyr->control.turn_fact, -1.0 ) );
}

scalar_t get_min_tux_speed()
{
    return MIN_TUX_SPEED;   
}

void set_friction_coeff( scalar_t fric[3] ) 
{
    fricCoeff[0] = fric[0];
    fricCoeff[1] = fric[1];
    fricCoeff[2] = fric[2];
} 

scalar_t get_min_y_coord() 
{
    scalar_t courseWidth, courseLength;
    scalar_t angle;
    scalar_t minY;

    get_course_dimensions( &courseWidth, &courseLength );
    angle = get_course_angle();

    minY = -courseLength * tan( angle * M_PI / 180.0 );
    return minY;
} 

void get_indices_for_point( scalar_t x, scalar_t z, 
			    int *x0, int *y0, int *x1, int *y1 )
{
    scalar_t courseWidth, courseLength;
    scalar_t xidx, yidx;
    int nx, ny;

    get_course_dimensions( &courseWidth, &courseLength );
    get_course_divisions( &nx, &ny );
    
    xidx = x / courseWidth * ( (scalar_t) nx - 1. );
    yidx = -z / courseLength * ( (scalar_t) ny - 1. );

    if (xidx < 0) {
        xidx = 0;
    } else if ( xidx > nx-1 ) {
        xidx = nx-1;
    } 

    if (yidx < 0) {
        yidx = 0;
    } else if ( yidx > ny-1 ) {
        yidx = ny-1;
    } 

    /* I found that ceil(3) was quite slow on at least some architectures, 
       so I've replace it with an approximation */
    *x0 = (int) (xidx);              /* floor(xidx) */
    *x1 = (int) ( xidx + 0.9999 );   /* ceil(xidx) */
    *y0 = (int) (yidx);              /* floor(yidx) */
    *y1 = (int) ( yidx + 0.9999 );   /* ceil(yidx) */

    if ( *x0 == *x1 ) {
	if ( *x1 < nx - 1 ) 
	    (*x1)++;
	else 
	    (*x0)--;
    } 

    if ( *y0 == *y1 ) {
	if ( *y1 < ny - 1 )
	    (*y1)++;
	else 
	    (*y0)--;
    } 

    check_assertion( *x0 >= 0, "invalid x0 index" );
    check_assertion( *x0 < nx, "invalid x0 index" );
    check_assertion( *x1 >= 0, "invalid x1 index" );
    check_assertion( *x1 < nx, "invalid x1 index" );
    check_assertion( *y0 >= 0, "invalid y0 index" );
    check_assertion( *y0 < ny, "invalid y0 index" );
    check_assertion( *y1 >= 0, "invalid y1 index" );
    check_assertion( *y1 < ny, "invalid y1 index" );
}

void find_barycentric_coords( scalar_t x, scalar_t z, 
			      point_t *p0, point_t *p1, point_t *p2,
			      scalar_t *u, scalar_t *v )
{
    scalar_t xidx, yidx;
    int nx, ny;
    int x0, x1, y0, y1;
    scalar_t dx, ex, dz, ez, qx, qz, invdet; /* to calc. barycentric coords */
    scalar_t courseWidth, courseLength;
    scalar_t *elevation;

    elevation = get_course_elev_data();
    get_course_dimensions( &courseWidth, &courseLength );
    get_course_divisions( &nx, &ny );

    get_indices_for_point( x, z, &x0, &y0, &x1, &y1 );
    
    xidx = x / courseWidth * ( (scalar_t) nx - 1. );
    yidx = -z / courseLength * ( (scalar_t) ny - 1. );

    if ( yidx - y0 < xidx - x0 ) {
        *p0 = make_point( (scalar_t)x0/(nx-1.)*courseWidth, ELEV(x0, y0), 
                       -(scalar_t)y0/(ny-1.)*courseLength );

        *p1 = make_point( (scalar_t)x1/(nx-1.)*courseWidth, ELEV(x1, y0), 
                       -(scalar_t)y0/(ny-1.)*courseLength );

        *p2 = make_point( (scalar_t)x1/(nx-1.)*courseWidth, ELEV(x1, y1), 
                       -(scalar_t)y1/(ny-1.)*courseLength );
    } else {
        *p0 = make_point( (scalar_t)x1/(nx-1.)*courseWidth, ELEV(x1, y1), 
                       -(scalar_t)y1/(ny-1.)*courseLength );

        *p1 = make_point( (scalar_t)x0/(nx-1.)*courseWidth, ELEV(x0, y1), 
                       -(scalar_t)y1/(ny-1.)*courseLength );

        *p2 = make_point( (scalar_t)x0/(nx-1.)*courseWidth, ELEV(x0, y0), 
                       -(scalar_t)y0/(ny-1.)*courseLength );
    } 

    dx = p0->x - p2->x;
    dz = p0->z - p2->z;
    ex = p1->x - p2->x;
    ez = p1->z - p2->z;
    qx = x - p2->x;
    qz = z - p2->z;

    invdet = 1./(dx * ez - dz * ex);
    *u = (qx * ez - qz * ex) * invdet;
    *v = (qz * dx - qx * dz) * invdet;
}

vector_t find_course_normal( scalar_t x, scalar_t z )
{
    vector_t *course_nmls;
    vector_t tri_nml;
    scalar_t xidx, yidx;
    int nx, ny;
    int x0, x1, y0, y1;
    point_t p0, p1, p2;
    vector_t n0, n1, n2;
    scalar_t courseWidth, courseLength;
    scalar_t u, v;
    scalar_t min_bary, interp_factor;
    vector_t smooth_nml;
    vector_t interp_nml;

    get_course_dimensions( &courseWidth, &courseLength );
    get_course_divisions( &nx, &ny );
    course_nmls = get_course_normals();

    get_indices_for_point( x, z, &x0, &y0, &x1, &y1 );
    
    xidx = x / courseWidth * ( (scalar_t) nx - 1. );
    yidx = -z / courseLength * ( (scalar_t) ny - 1. );

    find_barycentric_coords( x, z, &p0, &p1, &p2, &u, &v );

    if ( yidx - y0 < xidx - x0 ) {
        n0 = course_nmls[ x0 + nx * y0 ];
        n1 = course_nmls[ x1 + nx * y0 ];
        n2 = course_nmls[ x1 + nx * y1 ];
    } else {
        n0 = course_nmls[ x1 + nx * y1 ];
        n1 = course_nmls[ x0 + nx * y1 ];
        n2 = course_nmls[ x0 + nx * y0 ];
    } 

    smooth_nml = add_vectors( 
	scale_vector( u, n0 ),
	add_vectors( scale_vector( v, n1 ), scale_vector( 1.-u-v, n2 ) ) );

    tri_nml = cross_product( 
	subtract_points( p1, p0 ), subtract_points( p2, p0 ) );
    normalize_vector( &tri_nml );

    min_bary = min( u, min( v, 1. - u - v ) );
    interp_factor = min( min_bary / NORMAL_INTERPOLATION_LIMIT, 1.0 );

    interp_nml = add_vectors( 
	scale_vector( interp_factor, tri_nml ),
	scale_vector( 1.-interp_factor, smooth_nml ) );
    normalize_vector( &interp_nml );

    return interp_nml;
}

scalar_t find_y_coord( scalar_t x, scalar_t z )
{
    scalar_t ycoord;
    point_t p0, p1, p2;
    scalar_t u, v;

    /* cache last request */
    static scalar_t last_x, last_z, last_y;
    static bool_t cache_full = False;

    if ( cache_full && last_x == x && last_z == z ) {
	return last_y;
    }

    find_barycentric_coords( x, z, &p0, &p1, &p2, &u, &v );

    ycoord = u * p0.y + v * p1.y + ( 1. - u - v ) * p2.y;

    last_x = x;
    last_z = z;
    last_y = ycoord;
    cache_full = True;

    return ycoord;
} 

terrain_t get_surface_type( scalar_t x, scalar_t z )
{
    terrain_t *terrain;
    scalar_t courseWidth, courseLength;
    int xidx, yidx;
    int nx, ny;

    terrain = get_course_terrain_data();
    get_course_dimensions( &courseWidth, &courseLength );
    get_course_divisions( &nx, &ny );

    xidx = ceil( x / courseWidth * ( (scalar_t) nx - 1. ) );
    yidx = floor( -z / courseLength * ( (scalar_t) ny - 1. ) );

    if (xidx < 0) {
        xidx = 0;
    } else if ( xidx >= nx ) {
        xidx = nx-1;
    } 

    if (yidx < 0) {
        yidx = 0;
    } else if ( yidx >= ny ) {
        yidx = ny-1;
    } 

    return terrain[ xidx + nx*yidx ];
} 

void set_tux_pos( player_data_t *plyr, point_t new_pos )
{
    char *tuxRoot;
    scalar_t courseWidth, courseLength;
    scalar_t disp_y;

    get_course_dimensions( &courseWidth, &courseLength );


    if ( new_pos.x < 0 ) {
        new_pos.x = 0;
    } else if ( new_pos.x > courseWidth ) {
        new_pos.x = courseWidth;
    } 

    if ( new_pos.z > 0 ) {
        new_pos.z = 0;
    } else if ( -new_pos.z >= courseLength ) {
        new_pos.z = -courseLength;
        g_game.mode = GAME_OVER;
    } 

    plyr->pos = new_pos;

    disp_y = new_pos.y + TUX_Y_CORRECTION; 

    tuxRoot = get_tux_root_node();
    reset_scene_node( tuxRoot );
    translate_scene_node( tuxRoot, 
			  make_vector( new_pos.x, disp_y, new_pos.z ) );
} 

bool_t check_tree_collisions( point_t pos, point_t *tree_loc, 
			      scalar_t *tree_diam )
{
    tree_t *trees;
    int numTrees, i;
    scalar_t diam = 0.0; 
    scalar_t height;
    polyhedron_t ph, ph2;
    matrixgl_t mat;
    point_t loc;
    bool_t hit = False;
    vector_t distvec;
    char *tuxRoot;
    scalar_t squared_dist;
    
    /* These variables are used to cache collision detection results */
    static bool_t last_collision = False;
    static point_t last_collision_tree_loc = { -999, -999, -999 };
    static scalar_t last_collision_tree_diam = 0;
    static point_t last_collision_pos = { -999, -999, -999 };

    /* If we haven't moved very much since the last call, we re-use
       the results of the last call (significant speed-up) */
    vector_t dist_vec = subtract_points( pos, last_collision_pos );
    if ( MAG_SQD( dist_vec ) < COLLISION_TOLERANCE ) {
	if ( last_collision ) {
	    if ( tree_loc != NULL ) {
		*tree_loc = last_collision_tree_loc;
	    }
	    if ( tree_diam != NULL ) {
		*tree_diam = last_collision_tree_diam;
	    }
	    return True;
	} else {
	    return False;
	}
    }

    trees = get_tree_locs();
    numTrees = get_num_trees();
    ph = get_tree_polyhedron();

    for (i=0; i<numTrees; i++) {
        diam = trees[i].diam;
        height = trees[i].height;
        loc = trees[i].ray.pt;

        distvec = make_vector( loc.x - pos.x, 0.0, loc.z - pos.z );

	/* check distance from tree; .6 is the radius of a bounding
           sphere around tux (approximate) */
	squared_dist = ( diam/2. + 0.6 );
	squared_dist *= squared_dist;
        if ( MAG_SQD( distvec ) > squared_dist ) {
            continue;
        } 

        ph2 = copy_polyhedron( ph );

        make_scaling_matrix( mat, diam, height, diam );
        trans_polyhedron( mat, ph2 );
        make_translation_matrix( mat, loc.x, loc.y, loc.z );
        trans_polyhedron( mat, ph2 );

	tuxRoot = get_tux_root_node();
	reset_scene_node( tuxRoot );
	translate_scene_node( tuxRoot, 
			      make_vector( pos.x, pos.y, pos.z ) );
        hit = collide( tuxRoot, ph2 );

        free_polyhedron( ph2 );

        if ( hit == True ) {
	    if ( tree_loc != NULL ) {
		*tree_loc = loc;
	    }
	    if ( tree_diam != NULL ) {
		*tree_diam = diam;
	    }


            break;
        } 
    } 

    last_collision_tree_loc = loc;
    last_collision_tree_diam = diam;
    last_collision_pos = pos;

    if ( hit ) {
	last_collision = True;
    } else {
	last_collision = False;
    }

    return hit;
} 

scalar_t get_compression_depth( terrain_t surf_type ) 
{
    switch ( surf_type ) {
    case Ice:
	return 0.01;
    case Rock:
	return 0.001;
    case Snow:
	return 0.05;
    default:
	code_not_reached();
    }
}

/*
 * Check for tree collisions and adjust position and velocity appropriately.
 */
void adjust_for_tree_collision( point_t pos, vector_t *vel )
{
    vector_t treeNml;
    point_t treeLoc;
    bool_t treeHit;
    scalar_t speed;
    scalar_t costheta;
    scalar_t tree_diam;

    treeHit = check_tree_collisions( pos, &treeLoc, &tree_diam );
    if (treeHit) {
	/*
	 * Calculate the normal vector to the tree; here we model the tree
	 * as a vertical cylinder.
	 */
        treeNml.x = pos.x - treeLoc.x;
        treeNml.y = 0;
        treeNml.z = pos.z - treeLoc.z; 
        normalize_vector( &treeNml );

	/* Reduce speed by a minimum of 30% */
        speed = normalize_vector( vel );
        speed *= 0.7;

	/* 
	 * If Tux is moving into the tree, reduce the speed further, 
	 * and reflect the velocity vector off of the tree
	 */
        costheta = dot_product( *vel, treeNml );
        if (costheta < 0 ) {
	    /* Reduce speed */
	    
            speed *= 1 + costheta;
            speed *= 1 + costheta; 

	    /* Do the reflection */
            *vel = add_vectors( 
		scale_vector( -2. * dot_product( *vel, treeNml ) , treeNml ), 
		*vel );

	    normalize_vector( vel );

        } 

	speed = max( speed, get_min_tux_speed() );

        *vel = scale_vector( speed, *vel );
    } 
}

/*
 * Adjusts velocity so that his speed doesn't drop below the minimum 
 * speed
 */
scalar_t adjust_velocity( vector_t *vel, point_t pos, scalar_t surf_y, 
			  vector_t surf_nml )
{
    scalar_t speed;

    /* adjust_for_tree_collision( pos, vel ); */ 
    /* we do this in solve_ode_system now, see the comments there */

    speed = normalize_vector( vel );

    if ( speed < EPS )
    {
	if ( fabs( surf_nml.x ) + fabs( surf_nml.z ) > EPS ) {
	    *vel = project_into_plane( 
		surf_nml, make_vector( 0.0, -1.0, 0.0 ) );
	    normalize_vector( vel );
	} else {
	    *vel = make_vector( 0.0, 0.0, -1.0 );
	}
    }

    speed = max( get_min_tux_speed(), speed );

    *vel = scale_vector( speed, *vel );
    return speed;
}

void adjust_position( point_t *pos, scalar_t surf_y, terrain_t surf_type )
{
    /* No need to do anything */
    return;
}

void adjust_orientation( player_data_t *plyr, scalar_t dtime, 
			 point_t pos, vector_t vel,
			 scalar_t surf_y, vector_t surf_nml )
{
    vector_t new_x, new_y, new_z; 
    matrixgl_t cob_mat, inv_cob_mat;
    quaternion_t new_orient;
    char* tux_root;
    scalar_t time_constant;
    static vector_t z_vec = { 0., 0., 1. };
    static vector_t minus_y_vec = { 0., -1., 0. };

    if ( pos.y > surf_y ) {
        new_y = scale_vector( -1., vel );
        normalize_vector( &new_y );
        new_z = project_into_plane( new_y, make_vector(0., 1., 0.) );
        normalize_vector( &new_z);
    } else { 
        new_z = surf_nml;
        new_y = project_into_plane( surf_nml, scale_vector( -1., vel ) );
        normalize_vector(&new_y);
    }

    new_x = cross_product( new_y, new_z );

    make_change_of_basis_matrix( cob_mat, inv_cob_mat, new_x, new_y, new_z );

    new_orient = make_quaternion_from_matrix( cob_mat );

    if ( !plyr->orientation_initialized ) {
	plyr->orientation_initialized = True;
	plyr->orientation = new_orient;
    }

    time_constant = pos.y > surf_y 
	? TUX_ORIENTATION_AIRBORNE_TIME_CONSTANT
	: TUX_ORIENTATION_TIME_CONSTANT;

    plyr->orientation = interpolate_quaternions( 
	plyr->orientation, new_orient, 
	min( dtime / time_constant, 1.0 ) );

    plyr->plane_nml = rotate_vector( plyr->orientation, z_vec );
    plyr->direction = rotate_vector( plyr->orientation, minus_y_vec );

    make_matrix_from_quaternion( cob_mat, plyr->orientation );
    transpose_matrix( cob_mat, inv_cob_mat );

    tux_root = get_tux_root_node();
    transform_scene_node( tux_root, cob_mat, inv_cob_mat ); 
}

scalar_t adjust_particle_count( scalar_t particles ) 
{
    if ( particles < 1 ) {
	if ( ( (scalar_t) rand() ) / RAND_MAX < particles ) {
	    return 1.0;
	} else {
	    return 0.0;
	}
    } else {
	return particles;
    }
}

void generate_particles( player_data_t *plyr, scalar_t dtime, 
			 point_t pos, scalar_t speed ) 
{
    point_t left_part_pt, right_part_pt;
    vector_t part_vector = { 0., 1., 0. };
    scalar_t brake_particles;
    scalar_t turn_particles;
    terrain_t surf_type; 
    scalar_t surf_y;
    scalar_t left_particles, right_particles;

    surf_type = get_surface_type( pos.x, pos.z );
    surf_y = find_y_coord( pos.x, pos.z );

    if ( surf_type == Snow && pos.y < surf_y ) {
        right_part_pt = left_part_pt = pos;
	right_part_pt.x += 0.175;
	left_part_pt.x  -= 0.175;

	brake_particles = dtime *
	    BRAKE_PARTICLES * ( plyr->control.is_braking ? 1.0 : 0.0 )
	    * min( speed / PARTICLES_SPEED_FACTOR, 1.0 );
	turn_particles = dtime * MAX_TURN_PARTICLES 
	    * min( speed / PARTICLES_SPEED_FACTOR, 1.0 );

	left_particles = turn_particles * 
	    fabs( min(plyr->control.turn_fact, 0.) ) + 
	    brake_particles;

	right_particles = turn_particles * 
	    fabs( max(plyr->control.turn_fact, 0.) ) + 
	    brake_particles;

	left_particles = adjust_particle_count( left_particles );
	right_particles = adjust_particle_count( right_particles );

        create_new_particles( left_part_pt, part_vector, left_particles );
        create_new_particles( right_part_pt, part_vector, right_particles );
    } 
}

/*
 * Calculate the magnitude of force due to air resistance (wind)
 */
scalar_t calc_wind_force_mag( scalar_t wind_speed )
{
    scalar_t re;         /* Reynolds number */
    scalar_t df_mag;     /* magnitude of drag force */
    scalar_t drag_coeff; /* drag coefficient */
    int table_size;      /* size of drag coeff table */

    re = AIR_DENSITY * wind_speed * TUX_DIAMETER / AIR_VISCOSITY;

    table_size = sizeof(air_log_drag_coeff) / sizeof(air_log_drag_coeff[0]);

    drag_coeff = pow( 10.0, 
		      lin_interp( air_log_re, air_log_drag_coeff, 
				  log10(re), table_size ) );

    df_mag = 0.5 * drag_coeff * AIR_DENSITY * ( wind_speed * wind_speed )
	* ( M_PI * ( TUX_DIAMETER * TUX_DIAMETER ) * 0.25 );

    return df_mag;
}

static vector_t calc_spring_force( scalar_t compression, vector_t vel, 
				   vector_t surf_nml )
{
    scalar_t spring_vel; /* velocity perp. to surface (for damping) */
    scalar_t spring_f_mag; /* magnitude of force */

   check_assertion( compression >= 0, 
		    "spring can't have negative compression" );
    
    spring_vel = dot_product( vel, surf_nml );

    /* Stage 1 */
    spring_f_mag = 
	min( compression, TUX_GLUTE_STAGE_1_COMPRESSIBILITY ) 
	* TUX_GLUTE_STAGE_1_SPRING_COEFF;

    /* Stage 2 */
    spring_f_mag += 
	max( 0., compression - TUX_GLUTE_STAGE_1_COMPRESSIBILITY ) 
	* TUX_GLUTE_STAGE_2_SPRING_COEFF;

    /* Damping */
    spring_f_mag -= spring_vel * ( 
	compression <= TUX_GLUTE_STAGE_1_COMPRESSIBILITY 
	? TUX_GLUTE_STAGE_1_DAMPING_COEFF
	: TUX_GLUTE_STAGE_2_DAMPING_COEFF );

    /* Clamp */
    spring_f_mag = min( spring_f_mag, TUX_GLUTE_MAX_SPRING_FORCE );
    spring_f_mag = max( spring_f_mag, 0.0 );

    return scale_vector( spring_f_mag, surf_nml );
}


vector_t calc_net_force( player_data_t *plyr, point_t uncorr_pos, 
			 vector_t vel, bool_t *collision )
{
    vector_t nml_f;      /* normal force */
    scalar_t nml_f_mag;  /* and its magnitude */
    vector_t fric_f;     /* frictional force */
    vector_t fric_dir;   /* direction of frictional force */
    vector_t grav_f;     /* gravitational force */
    vector_t air_f;      /* air resistance force */
    vector_t brake_f;    /* braking force */
    vector_t net_force;  /* the net force (sum of all other forces) */
    scalar_t comp_depth; /* depth to which the terrain can be compressed */
    scalar_t speed;      /* speed (m/s) */
    scalar_t surf_y;     /* y coord of terrain surface */
    vector_t surf_nml;   /* normal to terrain at current position */
    terrain_t surf_type; /* type of terrain at current pos */
    point_t tree_loc;    /* location of tree */
    scalar_t tree_diam;  /* diameter of tree */
    vector_t tree_f;     /* force exterted by tree collisions */
    scalar_t glute_compression; /* amt that Tux's tush has been compressed */
    scalar_t steer_angle; /* Angle to rotate fricitonal force for turning */
    matrixgl_t fric_rot_mat; /* Matrix to rotate frictional force */

    surf_type = get_surface_type( uncorr_pos.x, uncorr_pos.z );
    surf_nml = find_course_normal( uncorr_pos.x, uncorr_pos.z );
    surf_y = find_y_coord( uncorr_pos.x, uncorr_pos.z );
    
    comp_depth = get_compression_depth( surf_type );

    grav_f = make_vector( 0, -EARTH_GRAV * TUX_MASS, 0 );

    /*
     * Calculate normal force
     */
    nml_f = make_vector( 0., 0., 0. );
    if ( uncorr_pos.y <= surf_y - comp_depth ) {
	/*
	 * Tux ended up below the surface.
	 * Calculate the spring force exterted by his rear end. :-)
	 */
	glute_compression = surf_y - comp_depth - uncorr_pos.y;
	check_assertion( glute_compression >= 0, 
			 "unexpected negative compression" );

	nml_f = calc_spring_force( glute_compression, vel, surf_nml );
    }

    /* 
     * Calculate frictional force
     */
    fric_dir = vel;
    speed = normalize_vector( &fric_dir );
    fric_dir = scale_vector( -1.0, fric_dir );
    
    if ( uncorr_pos.y <= surf_y ) {
	vector_t tmp_nml_f = nml_f;

	nml_f_mag = normalize_vector( &tmp_nml_f );

	fric_f = scale_vector( 
	    fricCoeff[surf_type] * nml_f_mag, fric_dir );


	/*
	 * Adjust friction for steering
	 */
	steer_angle = plyr->control.turn_fact * MAX_TURN_ANGLE;
	make_rotation_about_vector_matrix( fric_rot_mat, surf_nml, 
					   steer_angle );
	fric_f = transform_vector( fric_rot_mat, fric_f );
	fric_f = scale_vector( 
	    1.0 + fabs(plyr->control.turn_fact * MAX_TURN_PENALTY), fric_f );


	/*
	 * Calculate braking force
	 */
	if ( speed > get_min_tux_speed() && plyr->control.is_braking ) {
	    brake_f = scale_vector( 
		fricCoeff[surf_type] * BRAKE_FORCE, fric_dir ); 
	} else {
	    brake_f = make_vector( 0., 0., 0. );
	}
	
    } else {
	fric_f = brake_f = make_vector( 0., 0., 0. );
    }

    /*
     * Calculate air resistance
     */
    air_f = scale_vector( calc_wind_force_mag( speed ), fric_dir );


    /*
     * Calculate force from tree collisions
     */
    tree_f = make_vector( 0., 0., 0. );
    if ( check_tree_collisions( uncorr_pos, &tree_loc, &tree_diam ) ) {
	scalar_t tree_dist;
	vector_t tree_nml;

	*collision = True;

	tree_nml = subtract_points( uncorr_pos, tree_loc );
	tree_nml.y = 0;
	tree_dist = normalize_vector( &tree_nml );

	if ( tree_dist < tree_diam ) {
	    tree_f = calc_spring_force( tree_diam - tree_dist, 
					vel, tree_nml );
	}

    } else {
	*collision = False;
    }

    
    /*
     * Add all the forces 
     */
    net_force = add_vectors( grav_f, add_vectors( nml_f, add_vectors( 
	fric_f, add_vectors( air_f, add_vectors( brake_f, tree_f )))));

    return net_force;
}

static scalar_t adjust_time_step_size( scalar_t h, vector_t vel )
{
    scalar_t speed;

    speed = normalize_vector( &vel );

    h = max( h, MIN_TIME_STEP );
    h = min( h, MAX_STEP_DISTANCE / speed );
    h = min( h, MAX_TIME_STEP );

    return h;
}

/*
 * Solves the system of ordinary differential equations governing Tux's 
 * movement.  Based on Matlab's ode23.m, (c) The MathWorks, Inc.
 */
void solve_ode_system( player_data_t *plyr, scalar_t dtime ) 
{
    double t0, t, tfinal;
    ode_data_t *x, *y, *z, *vx, *vy, *vz; /* store estimates of derivs */
    ode_solver_t solver;
    double h;
    bool_t done = False;
    bool_t failed = False;
    point_t new_pos;
    vector_t new_vel, tmp_vel;
    scalar_t speed;
    vector_t new_f;
    point_t saved_pos;
    vector_t saved_vel, saved_f;
    bool_t collision;
    double pos_err[3], vel_err[3], tot_pos_err, tot_vel_err;
    double err=0, tol=0;
    int i;

    /* Select a solver */
    switch ( getparam_ode_solver() ) {
    case EULER:
	solver = new_euler_solver();
	break;
    case ODE23:
	solver = new_ode23_solver();
	break;
    case ODE45:
	solver = new_ode45_solver();
	break;
    default:
	setparam_ode_solver( ODE23 );
	solver = new_ode23_solver();
    }

    /* Select an initial time step */
    h = ode_time_step;

    if ( h < 0 || solver.estimate_error == NULL ) {
	h = adjust_time_step_size( dtime, plyr->vel );
    }

    t0 = 0;
    tfinal = dtime;

    t = t0;

    /* Create variables to store derivative estimates & other data */
    x  = solver.new_ode_data();
    y  = solver.new_ode_data();
    z  = solver.new_ode_data();
    vx = solver.new_ode_data();
    vy = solver.new_ode_data();
    vz = solver.new_ode_data();

    /* initialize state */
    new_pos = plyr->pos;
    new_vel = plyr->vel;
    new_f   = plyr->net_force;

    /* loop until we've integrated from t0 to tfinal */
    while (!done) {

	if ( t >= tfinal ) {
	    print_warning( CRITICAL_WARNING, 
			   "t >= tfinal in solve_ode_system()" );
	    break;
	}

	/* extend h by up to 10% to reach tfinal */
	if ( 1.1 * h > tfinal - t ) {
	    h = tfinal-t;
	    check_assertion( h >= 0., "integrated past tfinal" );
	    done = True;
	}

        print_debug( DEBUG_ODE, "h: %g", h );

	saved_pos = new_pos;
	saved_vel = new_vel;
	saved_f = new_f;

	/* Loop until error is acceptable */
	failed = False;

	for (;;) {

	    /* Store initial conditions */
	    solver.init_ode_data( x, new_pos.x, h );
	    solver.init_ode_data( y, new_pos.y, h );
	    solver.init_ode_data( z, new_pos.z, h );
	    solver.init_ode_data( vx, new_vel.x, h );
	    solver.init_ode_data( vy, new_vel.y, h );
	    solver.init_ode_data( vz, new_vel.z, h );


	    /* We assume that the first estimate in all ODE solvers is equal 
	       to the final value of the last iteration */
	    solver.update_estimate( x, 0, new_vel.x );
	    solver.update_estimate( y, 0, new_vel.y );
	    solver.update_estimate( z, 0, new_vel.z );
	    solver.update_estimate( vx, 0, new_f.x / TUX_MASS );
	    solver.update_estimate( vy, 0, new_f.y / TUX_MASS );
	    solver.update_estimate( vz, 0, new_f.z / TUX_MASS );

	    /* Update remaining estimates */
	    for ( i=1; i < solver.num_estimates(); i++ ) {
		new_pos.x = solver.next_val( x, i );
		new_pos.y = solver.next_val( y, i );
		new_pos.z = solver.next_val( z, i );
		new_vel.x = solver.next_val( vx, i );
		new_vel.y = solver.next_val( vy, i );
		new_vel.z = solver.next_val( vz, i );

		solver.update_estimate( x, i, new_vel.x );
		solver.update_estimate( y, i, new_vel.y );
		solver.update_estimate( z, i, new_vel.z );

		new_f = calc_net_force( plyr, new_pos, new_vel, &collision );

#if USE_MIN_TIME_STEP_FOR_TREE_COLLISIONS

		if ( collision && h > MIN_TIME_STEP + EPS ) {
		    /* If a collision is detected, use min time step */
		    break;
		}

#endif /* USE_MIN_TIME_STEP_FOR_TREE_COLLISIONS */


		solver.update_estimate( vx, i, new_f.x / TUX_MASS );
		solver.update_estimate( vy, i, new_f.y / TUX_MASS );
		solver.update_estimate( vz, i, new_f.z / TUX_MASS );
	    }

#if USE_MIN_TIME_STEP_FOR_TREE_COLLISIONS

	    if ( collision && h > MIN_TIME_STEP + EPS ) {
		/* If a collision is detected, use min time step */
		h = MIN_TIME_STEP;

		/* re-start the evaulation */
		new_pos = saved_pos;
		new_vel = saved_vel;
		new_f = saved_f;
		continue;
	    }

#endif /* USE_MIN_TIME_STEP_FOR_TREE_COLLISIONS */

	    /* Get final values */
	    new_pos.x = solver.final_estimate( x );
	    new_pos.y = solver.final_estimate( y );
	    new_pos.z = solver.final_estimate( z );

	    new_vel.x = solver.final_estimate( vx );
	    new_vel.y = solver.final_estimate( vy );
	    new_vel.z = solver.final_estimate( vz );

	    /* If the current solver can provide error estimates, update h
	       based on the error, and re-evaluate this step if the error is 
	       too large  */
	    if ( solver.estimate_error != NULL ) {

		/* Calculate the error */
		pos_err[0] = solver.estimate_error( x );
		pos_err[1] = solver.estimate_error( y );
		pos_err[2] = solver.estimate_error( z );

		vel_err[0] = solver.estimate_error( vx );
		vel_err[1] = solver.estimate_error( vy );
		vel_err[2] = solver.estimate_error( vz );

		tot_pos_err = 0.;
		tot_vel_err = 0.;
		for ( i=0; i<3; i++ ) {
		    pos_err[i] *= pos_err[i];
		    tot_pos_err += pos_err[i];
		    vel_err[i] *= vel_err[i];
		    tot_vel_err += vel_err[i];
		}
		tot_pos_err = sqrt( tot_pos_err );
		tot_vel_err = sqrt( tot_vel_err );

                print_debug( DEBUG_ODE, "pos_err: %g, vel_err: %g", 
			     tot_pos_err, tot_vel_err );

		if ( tot_pos_err / MAX_POSITION_ERROR >
		     tot_vel_err / MAX_VELOCITY_ERROR )
		{
		    err = tot_pos_err;
		    tol = MAX_POSITION_ERROR;
		} else {
		    err = tot_vel_err;
		    tol = MAX_VELOCITY_ERROR;
		}

		/* Update h based on error */
		if (  err > tol  && h > MIN_TIME_STEP + EPS  )
		{
		    done = False;
		    if ( !failed ) {
			failed = True;
			h *=  max( 0.5, 0.8 *
				   pow( tol/err, 
					solver.time_step_exponent() ) );
		    } else {
			h *= 0.5;
		    }

		    h = adjust_time_step_size( h, saved_vel );

		    new_pos = saved_pos;
		    new_vel = saved_vel;
		    new_f = saved_f;
		
		} else {
		    /* Error is acceptable or h is at its minimum; stop */
		    break;
		}

	    } else {
		/* Current solver doesn't provide error estimates; stop */
		break;
	    }
	}

	/* Update time */
	t = t + h;

	tmp_vel = new_vel;
	speed = normalize_vector( &tmp_vel );

	/* only generate particles if we're drawing them */
	if ( getparam_draw_particles() ) {
	    generate_particles( plyr, h, new_pos, speed );
	}

	/* If no failures, compute a new h */
	if ( !failed && solver.estimate_error != NULL ) {
	    double temp = 1.25 * pow(err / tol, solver.time_step_exponent());
	    if ( temp > 0.2 ) {
		h = h / temp;
	    } else {
		h = 5.0 * h;
	    }
	}

	/* Clamp h to constraints */
	h = adjust_time_step_size( h, new_vel );

	/* Important: to make trees "solid", we must manipulate the 
	   velocity here; if we don't and Tux is moving very quickly,
	   he can pass through trees */
	adjust_for_tree_collision( new_pos, &new_vel );

    }

    /* Save time step for next time */
    ode_time_step = h;

    plyr->vel = new_vel;
    plyr->pos = new_pos;
    plyr->net_force = new_f;

    free( x );
    free( y );
    free( z );
    free( vx );
    free( vy );
    free( vz );
}


/* 
 * Updates Tux's position taking into account gravity, friction, tree 
 * collisions, etc.  This is the main physics function.
 */
void update_player_pos( player_data_t *plyr, scalar_t dtime )
{
    scalar_t surf_y;     /* y coord of terrain */
    vector_t surf_nml;   /* normal vector of terrain */
    terrain_t surf_type; /* type of terrain */
    vector_t tmp_vel;
    scalar_t speed;

    if ( dtime > 2. * EPS ) {
	solve_ode_system( plyr, dtime );
    }

    /*
     * Set position, orientation, generate particles
     */
    surf_type = get_surface_type( plyr->pos.x, plyr->pos.z );
    surf_nml = find_course_normal( plyr->pos.x, plyr->pos.z );
    surf_y = find_y_coord( plyr->pos.x, plyr->pos.z );
    adjust_velocity( &plyr->vel, plyr->pos, surf_y, 
		     surf_nml );
    adjust_position( &plyr->pos, surf_y, surf_type );

    tmp_vel = plyr->vel;
    speed = normalize_vector( &tmp_vel );

    set_tux_pos( plyr, plyr->pos );
    adjust_orientation( plyr, dtime, plyr->pos, plyr->vel, 
			surf_y, surf_nml );
    adjust_tux_joints( plyr->control.turn_fact, plyr->control.is_braking );
}


void init_physical_simulation()
{
    point2d_t start_pt;
    vector_t nml;
    matrixgl_t rotMat;
    scalar_t ycoord;
    player_data_t *plyr;
    vector_t init_vel;
    vector_t init_f;
    int i;

    start_pt = get_start_pt();
    ycoord = find_y_coord( start_pt.x, start_pt.y );
    nml = find_course_normal( start_pt.x, start_pt.y );
    make_rotation_matrix( rotMat, -90., 'x' );
    init_vel = transform_vector( rotMat, nml );
    init_vel = scale_vector( INIT_TUX_SPEED, init_vel );
    init_f = make_vector( 0., 0., 0. );

    for ( i=0; i<g_game.num_players; i++ ) {
	plyr = get_player_data( i );
	plyr->pos.x = start_pt.x;
	plyr->pos.y = ycoord;
	plyr->pos.z = start_pt.y;
	plyr->vel = init_vel;
	plyr->net_force = init_f;
	plyr->orientation_initialized = False;
	plyr->control.turn_fact = 0.0;
	plyr->control.is_braking = False;
    }

    ode_time_step = -1;
} 


